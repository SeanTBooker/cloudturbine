
// Example of a plugin to check and apply license headers;
// see https://github.com/hierynomus/license-gradle-plugin
//
// plugins {
//     id "com.github.hierynomus.license" version "0.13.1"
// }
// license {
//     header rootProject.file('../HEADER')
//     dryRun true
//     strictCheck true
//     ext.year = Calendar.getInstance().get(Calendar.YEAR)
//     ext.name = 'Erigo Technologies LLC'
// }

// Here's another way to define "resources" which will be included in the
// JAR file (will be put at the top level in the JAR file).
//sourceSets {
//	main {
//		resources {
//			srcDir "$projectDir"
//			include "COPYING"
//			include "COPYING.LESSER"
//			include "LICENSE.txt"
//			include "NOTICE.txt"
//		}
//	}
//}

// JAR settings
// Specify ".doFirst" to force this to run in the Execution phase.  Without
// this specification, this would be run during the Configuration phase, which
// would fail if CTlib.jar didn't yet exist; at Execution phase, CTlib.jar
// should have been created already.
jar.doFirst {
    // Create a "fat jar" file which includes all the dependencies; that way,
    // the jar can be run stand-alone with none of the other dependency jars
    // around.  The following was taken from a nice simple example found at:
    // https://newfivefour.com/gradle-hello-world-java-fat-jar.html
    // The "it" variable (kind of like "this" in Java) is a Groovy-ism which
    // represents the implicit variable given to this closure, which I think is
    // the project object.
    from {
        (configurations.runtime).collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }
    
    // CTserial will now be covered under Apache 2.0 license, so no need to
    // include these other license files in the JAR.
    // Include license files in the JAR's META-INF directory
    // Note that this isn't an Apache project as the other project's are
    // into("META-INF") {
    // 	from "$projectDir/COPYING", "$projectDir/COPYING.LESSER", "$projectDir/LICENSE.txt", "$projectDir/NOTICE.txt"
    // }
    
    // Build up a string containing all the runtime dependencies; this will be
    // used as the 'Class-Path' string in the manifest instead of hard-wiring
    // library names
    StringBuilder sb = new StringBuilder();
    project.configurations.runtime.each {
        sb.append(it.name + ' ')
    }
    String runtimeDependenciesStr = sb.toString().trim()
    
    manifest {
        attributes 'Main-Class': 'erigo.ctserial.CTserial',
                   'Class-Path': runtimeDependenciesStr
    }
}

repositories {
    flatDir {
    	// Location of CTlib.jar
    	dirs "$rootProject.projectDir/CTlib/build/libs"
    }
}

dependencies {
	// Build CTlib project first, because we use CTlib.jar
	compile project(':CTlib')
	// Specify that we use CTlib.jar
    compile name: 'CTlib'
    compile group: 'commons-cli', name: 'commons-cli', version: '1.3.1'
    // jSerialComm 2.0.2 can be redistributed under Apache 2.0
    // compile 'com.fazecast:jSerialComm:1.3.11'
    compile 'com.fazecast:jSerialComm:2.0.2'
}
